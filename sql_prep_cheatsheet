#SQL

#NORMALIZATION
1NF (First Normal Form) Rules
Each table cell should contain a single value.
Each record needs to be unique.

The data depends on the key [1NF],
the whole key [2NF] + [1NF]
and nothing but the key [3NF] + [2NF].
BCNF - Boyce-Codd, When Primary key = All other columns 

#KEYS
super keys: all kind of keys including redundant columns.
candidate keys: unique keys that doesn't need to include redundant keys, subset of super keys.
primary keys: one unique key that are taken from candidate keys.
alternate keys: all other candidate keys that are not chosen as a primary one.
Compound(can have foreigh keys)
Composite(may or may not have foreighn keys)
Surrogate key -an artificial key which aims to uniquely identify each record
Foreighn key can be null

https://www.guru99.com/dbms-keys.html

#INDEXES
B-TREE (Always balanced, depth is equal at every leaf)
Tree + Double LinkedList
O(log(n)) - for B-tree,

why index might be slow?
An index lookup requires three steps: (1) the tree traversal; (2) following the leaf node chain; (3) fetching the table data.

Even though the two-index solution delivers very good select performance as well, the single-index solution is preferable.
It not only saves storage space, but also the maintenance overhead for the second index.
The fewer indexes a table has, the better the insert, delete and update performance.

The query optimizer, or query planner, is the database component that transforms an SQL statement into an execution plan. This process is also called compiling or parsing. There are two distinct optimizer types.
Cost-based optimizers (CBO) generate many execution plan variations and calculate a cost value for each plan. The cost calculation is based on the operations in use and the estimated row numbers. In the end the cost value serves as the benchmark for picking the “best” execution plan.
Rule-based optimizers (RBO) generate the execution plan using a hard-coded rule set. Rule based optimizers are less flexible and are seldom used today.

The efficiency of an INDEX RANGE SCAN may vary over a wide range—especially when followed by a table access. Using an index does not automatically mean a statement is executed in the best way possible.

PostgreSQL and the Oracle database trust the DETERMINISTIC or IMMUTABLE declarations—that means they trust the developer.

Indx types:
B-Tree - For most datatypes and queries
GIN - For JSONB/hstore/arrays
GiST - For full text search and geospatial datatypes
SP-GiST - For larger datasets with natural but uneven clustering
BRIN - For really large datasets that line up sequentially
Hash - For equality operations, and generally B-Tree still what you want here

#STATISTICS
VACUUM -- garbage-collect and optionally analyze a database
VACUUM ANALYZE performs a VACUUM and then an ANALYZE for each selected table.

High cardinality means that the column contains a large percentage of totally unique values.
Low cardinality means that the column contains a lot of “repeats” in its data range
Cardinality relationships between tables can take the form of one-to-one,
one-to-many (whose reversal is many-to-one) or many-to-many. 

#TUNING/OPTIMIZATION

In all reality, there are only a few cases in which the actual values affect the execution plan. You should therefore use bind parameters if in doubt—just to prevent SQL injections.
A partial index is useful for commonly used where conditions that use constant values

# WAREHOUSE CONCEPTS
SCD types.
DIMENSIONAL MODELLING
OLAP CUBES

#STATISTICS
Mode
Mean
Median
